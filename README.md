# Домашняя работа №7. Изучение возможностей библиотеки BOOST  
1. [Задание](#task)  
    1.1 [Условие](#task_description)  
    1.2 [Самоконтроль](#selfcontrol)  
    1.3 [Проверка](#checking)  
2. [Описание работы программы](#prog_description)  
    2.1 [Краткое описание](#comments)  
    2.2 [Сборка и запуск](#build)  
    2.3 [Тестирование](#testing)  
  
## Задание 7 - bayan <a name="task"></a>  

### Условие <a name="task_description"></a>  
Пользуясь имеющимися в библиотеке Boost структурами и алгоритмами разработать утилиту для обнаружения файлов-дубликатов. Утилита должна иметь возможность через параметры командной строки указывать  
• директории для сканирования (может быть несколько)  
• директории для исключения из сканирования (может быть несколько)  
• уровень сканирования (1 - на все директории, 0 - только указанная директория без вложенных)  
• минимальный размер файла, по умолчанию проверяются все файлы больше 1 байта.  
• маски имен файлов разрешенных для сравнения (не зависят от регистра)  
• размер блока, которым производится чтения файлов, в задании этот размер упоминается как S  
• один из имеющихся алгоритмов хэширования (crc32, md5 - конкретные варианты определить самостоятельно), в задании эта функция упоминается как H. 
Результатом работы утилиты должен быть список полных путей файлов с идентичным содержимым, выводимый на стандартный вывод. На одной строке один файл. Идентичные файлы должны подряд, одной группой. Разные группы разделяются пустой строкой. Обязательно свойство утилиты - бережное обращение с дисковым вводом выводом. Каждый файл может быть представлен в виде списка блоков размера S. Если размер файла не кратен, он дополняется бинарными нулями.  
  
Файл world.txt из одной строки  
  
Hello, World\n
  
При размере блока в 5 байт, будет представлен как  
Hello  
, Wor  
ld\n\0\0  
  
Каждый блок должен быть свернут выбранной функцией хэширования. Возможные коллизии игнорируются. Из предположения, что  
H("Hello") == A  
H(", Wor") == B  
H("ld\n\0\0") == C,  
наш файл world.txt может быть представлен в виде последовательности ABC.  
  
Рассмотрим второй файл cpp.txt  
Hello, C++\n,  
который после хэширования блоков  
H("Hello") == A  
H(", C++") == D  
H("\n\0\0\0\0") == E  
может быть представлен в виде последовательности ADE.  
Порядок сравнения этих файлов должен быть максимально бережным. То есть обработка первого файла world.txt вообще не приводит к чтению с диска, ведь нам еще не с чем сравнивать. Как только мы добираемся до файла cpp.txt только в этот момент происходит перое чтение первого блока обоих файлов. В данном случае блоки идентичны, и необходимо прочесть вторые блоки, которые уже различаются. Файлы различны, оставшиеся данные не читаются.  
Файлы считаются идентичными при полном совпадении последовательности хешей блоков.  
  
### Самоконтроль <a name="selfcontrol"></a>  
• блок файла читается с диска не более одного раза  
• блок файла читается только в случае необходимости  
• не забыть, что дубликатов может быть больше чем два  
• пакет bayan содержащий исполняемый файл bayan опубликован на bintray  
• описание параметров в файле README.md корне репозитория  
• отправлена на проверку ссылка на страницу репозитория  
  
### Проверка <a name="checking"></a>  
Задание считается выполнено успешно, если после просмотра кода, подключения репозитория, установки пакета и запуска бинарного файла командой (параметры из описания):  
```bash  
$ bayan [...]  
```  
будут обнаружены файлы-дубликаты, без ложных срабатываний и пропуска существующих дубликатов.  
Количество прочитанных данных с диска минимально.  
  
## Описание работы программы <a name="prog_description"></a>  

### Краткое описание <a name="comments"></a>  
Программа bayan - утилита командной строки, которая позволяет найти группы дубликатов файлов. 
|Параметр|Значение по умолчанию|Описание|
|--------|---------------------|--------|
|help(h)||Вызов краткой сводки поддерживаемых параметров|
|incdir(i)|./|Директория для сканирования|
|excdir(e)|(пустой список)|Директория для исключения из сканирования|
|level(l)|0|Уровень сканирования (0 - не сканировать вложения, 1 - сканировать вложения)|
|mask(m)|.\*|Маска сканирования в формате регулярного выражения: ".\*part1.\*part2.\*part3.\*"|
|minsize(s)|1|Минимальный размер файлов|
|blocksize(b)|1|Размер блока, по которому производится четние каждого файла|
|hashtype(t)|0|Алгоритм хэширования читаемого из файла блока: 0 - MD5, 1 - CRC32|  
  
Пример вызова:  
```bash  
$ bayan -i ./ -i ../ -e ./subdir --level=1 -m .*txt --minsize=0 -b 128 -t 1  
```  
  
Алгоритм программы.  
1. Фильтр входных параметров.  
 - Если в какой-либо комбинации опций есть высоз справки (--help или -h), то будет выполнен только вызов справки.  
 - Если не указано ниодной директории для сканирования (опция -i), то по умолчанию выполнится сканирование текущей директории.  
 - При попытке указать минимальный размер блока (опция -b) < 1, сканирование выполнится с данный параметром по умолчанию.  
2. На основании параметров incdir, excdir, level, mask, minsize формируется список файлов для сканирования. Описание функции, выполняющей эту часть алгоритма, [здесь](https://sanlav89.github.io/otus_homework_07/classfilesfilter_1_1_same_files_finder.html#a3a376a3de8dd3ac9dc5a0e6cba027756)  
3. Формирование групп файлов-дубликатов (используюься параметры blocksize, hashtype). Рекурсивное поблочное чтение файлов из списка с хэшированием. Описание функции, выполняющей эту часть алгоритма, [здесь](https://sanlav89.github.io/otus_homework_07/classfilesfilter_1_1_same_files_finder.html#a3a376a3de8dd3ac9dc5a0e6cba027756)  
  
  
### Сборка и запуск <a name="build"></a>  
  
1. Сборка  
```bash  
$ cd <otus_homework_01_dir>  
$ mkdir ../build  
$ cd ../build  
$ cmake . -DPATCH_VERSION=123  
$ cmake --build ..  
$ cmake --build .. --target test  
$ cmake --build .. --target package  
```  
  
2. Запуск  
```bash  
$ ./bayan -i ../otus_homework_07/_test_folder/ -l 1  
/home/OTUS/otus_homework_07/_test_folder/dir1/dir3/dir4/dublicate_3_4.txt  
/home/OTUS/otus_homework_07/_test_folder/dir1/dir3/dublicate_3_3.txt  
/home/OTUS/otus_homework_07/_test_folder/dir1/dublicate_3_1.txt  
/home/OTUS/otus_homework_07/_test_folder/dir2/dublicate_3_2.txt  
  
/home/OTUS/otus_homework_07/_test_folder/dir1/dublicate_2_1.txt  
/home/OTUS/otus_homework_07/_test_folder/dir2/dublicate_2_2.txt  
  
/home/OTUS/otus_homework_07/_test_folder/dir1/dublicate_1_1.txt  
/home/OTUS/otus_homework_07/_test_folder/dir2/dublicate_1_2.txt  
```  
### Тестирование <a name="testing"></a>  
  
Для тестирования создана директория с тестовыми (otus_homework_07/\_test_folder) файлами и несколькими вложенными директориями. Для простоты все тестовые файлы имеют расширение ".\*txt". Формат названия для файлов, являющихся дубликатами:  
  
*dublicate\_(GROUP)\_(NUMBER).txt ,*  
  
где *GROUP* - номер порядковый номер группы дубликатов, *NUMBER* - порядковый номер файла внутри группы.  
Формат названия для файлов, не явзяющихся дубликаоами:  
  
*nondublicate\_(NUMBER).txt ,*  
  
где *NUMBER* - порядковый номер файла.  
  
[Пример теста](https://github.com/sanlav89/otus_homework_07#build), который выводит все группы дубликатов файлов, находящихся в директории otus_homework_07/_test_folder.  
  
Другие тесты, использующие эти тестовые данные, выполнены [здесь](https://github.com/sanlav89/otus_homework_07/blob/master/test_samefilesfinder.cpp).  
  
Также выполнены [unit-тесты](https://github.com/sanlav89/otus_homework_07/blob/master/test_hash.cpp) алгоритмов хэширования  
  
  